#1 This Database is Reverse Engineered from SQLite Dirtbike.db in ./SQLDATA/. 
[NOTE .CSPROJ COPIES DB TO API ROOT OF COMPILED BINARY ON AZURE THIS IS A WINDOWS DIRECTORY IN C:/HOME/USER/SQLDATA] 
[NOTES ON LINUX BINARIES UNDER SYSTEMD-> ITS DEFINED IN /ETC/SYSTEMD/SYSTEM/SERVICENAME.SERVICE WHICH HAS A WORKING DIRECTORY PATH TO THE ROOT DIRECTORY]

#2 ./SQLLITE/ contains the SQLite3 binaries for Windows Usage without Admin Installation Requirements. On Linux this is /usr/bin and is already in the path. On Windows you have to CD into this directory or add the path update.

#3 DATA  reverse engineering the database adds the Context to the Data directory.... as in a Large System with Many Models its hard to locate sometimes.

#4 ServicesBusiness contains all business logic.

#5 ServicesSecurity contains all security logic.

#6 Services for CLI/NOTIFICATION/USER Functions have their own self explanatory directories.

#7 Views simply contains the views necessary to review areas with multitable joins.

#8 Models contains the Reverse Engineered Database Output for each table. Its Plus 30 Tables.

#9 Controllers contains the Rest Endpoints for Each Table defined in Models plus a few extra(Auth).
a)Each Controller is based on a Template which presents single table operations for Get, Post, and Delete without any need to modify them.
b)Updates for Each Controller without modification expect a full Post record which becomes cumbersome for many attribute tables, and makes UI more difficult. We have gone to a checker process which
accepts a full or partial record, and ignores nulls in strings to prevent overwriting real data already in the tables. VS makes all null integers zero into the database and this also needs to be avoided as well.
c)As a result each controller supports Get, and ID centric operations with the ID representing Record Sequence Numbers as Keys Autogenerated in each table. Some tables neeed user based Identity Queries extending the 
requests to Post, Get, and Update for specific Users. All Controller files have less than 7 endpoints except for some very complicated programs like Cart, which need multiple queries based on multiple index values.
d) In Summary CRUD Operations for the Record ID are included with every Table, and there are additional ones for User, and Transaction Endpoints.

#10 Utilities included initial efforts to take .csv files and turn them into JSONs and vice versa. We had Copilot generate us some samples so we could build a CLI installer 
(Although we had a more complicated one we built in 547 last fall).

#11 We decided to extend the IO Architecture we built for Gashub Project which could allow for bulk User Uploads if nothing else. With a File Controller we can update and deposit IO files, and then process them in bulk.
